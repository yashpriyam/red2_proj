{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React, { forwardRef, useCallback, useContext, useEffect, useRef, useState } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { defaultProps } from '../../default-props';\nimport { Box } from '../Box';\nimport { Button } from '../Button';\nimport { Drop } from '../Drop';\nimport { FormContext } from '../Form/FormContext';\nimport { Keyboard } from '../Keyboard';\nimport { StyledMaskedInput, StyledMaskedInputContainer, StyledIcon } from './StyledMaskedInput';\n\nvar parseValue = function parseValue(mask, value) {\n  // break the value up into mask parts\n  var valueParts = []; // { part, beginIndex, endIndex }\n\n  var valueIndex = 0;\n  var maskIndex = 0;\n\n  while (value !== undefined && valueIndex < value.length && maskIndex < mask.length) {\n    var item = mask[maskIndex];\n    var found = void 0;\n\n    if (item.fixed) {\n      var length = item.fixed.length;\n      valueParts.push({\n        part: item.fixed,\n        beginIndex: valueIndex,\n        endIndex: valueIndex + length - 1\n      });\n      var part = value.slice(valueIndex, valueIndex + length);\n\n      if (part === item.fixed) {\n        valueIndex += length;\n      }\n\n      maskIndex += 1;\n      found = true;\n    } else if (item.options) {\n      // reverse assuming larger is later\n      found = item.options.slice(0).reverse() // eslint-disable-next-line no-loop-func\n      .some(function (option) {\n        var length = option.length;\n        var part = value.slice(valueIndex, valueIndex + length);\n\n        if (part === option) {\n          valueParts.push({\n            part: part,\n            beginIndex: valueIndex,\n            endIndex: valueIndex + length - 1\n          });\n          valueIndex += length;\n          maskIndex += 1;\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    if (!found) {\n      if (item.regexp) {\n        var minLength = Array.isArray(item.length) && item.length[0] || item.length || 1;\n        var maxLength = Array.isArray(item.length) && item.length[1] || item.length || value.length - valueIndex;\n        var _length = maxLength;\n\n        while (!found && _length >= minLength) {\n          var _part = value.slice(valueIndex, valueIndex + _length);\n\n          if (item.regexp.test(_part)) {\n            valueParts.push({\n              part: _part,\n              beginIndex: valueIndex,\n              endIndex: valueIndex + _length - 1\n            });\n            valueIndex += _length;\n            maskIndex += 1;\n            found = true;\n          }\n\n          _length -= 1;\n        }\n\n        if (!found) {\n          valueIndex = value.length;\n        }\n      } else {\n        var _length2 = Array.isArray(item.length) ? item.length[1] : item.length || value.length - valueIndex;\n\n        var _part2 = value.slice(valueIndex, valueIndex + _length2);\n\n        valueParts.push({\n          part: _part2,\n          beginIndex: valueIndex,\n          endIndex: valueIndex + _length2 - 1\n        });\n        valueIndex += _length2;\n        maskIndex += 1;\n      }\n    }\n  }\n\n  return valueParts;\n};\n\nvar defaultMask = [];\nvar MaskedInput = forwardRef(function (_ref, ref) {\n  var focusProp = _ref.focus,\n      icon = _ref.icon,\n      id = _ref.id,\n      _ref$mask = _ref.mask,\n      mask = _ref$mask === void 0 ? defaultMask : _ref$mask,\n      name = _ref.name,\n      _onBlur = _ref.onBlur,\n      onChange = _ref.onChange,\n      _onFocus = _ref.onFocus,\n      onKeyDown = _ref.onKeyDown,\n      placeholder = _ref.placeholder,\n      plain = _ref.plain,\n      reverse = _ref.reverse,\n      valueProp = _ref.value,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"focus\", \"icon\", \"id\", \"mask\", \"name\", \"onBlur\", \"onChange\", \"onFocus\", \"onKeyDown\", \"placeholder\", \"plain\", \"reverse\", \"value\"]);\n\n  var theme = useContext(ThemeContext) || defaultProps.theme;\n  var formContext = useContext(FormContext);\n\n  var _formContext$useFormC = formContext.useFormContext(name, valueProp, ''),\n      value = _formContext$useFormC[0],\n      setValue = _formContext$useFormC[1];\n\n  var _useState = useState(parseValue(mask, value)),\n      valueParts = _useState[0],\n      setValueParts = _useState[1];\n\n  useEffect(function () {\n    setValueParts(parseValue(mask, value));\n  }, [mask, value]);\n  var inputRef = useRef();\n  var dropRef = useRef();\n\n  var _useState2 = useState(focusProp),\n      focus = _useState2[0],\n      setFocus = _useState2[1];\n\n  var _useState3 = useState(),\n      activeMaskIndex = _useState3[0],\n      setActiveMaskIndex = _useState3[1];\n\n  var _useState4 = useState(),\n      activeOptionIndex = _useState4[0],\n      setActiveOptionIndex = _useState4[1];\n\n  var _useState5 = useState(),\n      showDrop = _useState5[0],\n      setShowDrop = _useState5[1];\n\n  useEffect(function () {\n    if (focus) {\n      var timer = setTimeout(function () {\n        // determine which mask element the caret is at\n        var caretIndex = (ref || inputRef).current.selectionStart;\n        var maskIndex;\n        valueParts.some(function (part, index) {\n          if (part.beginIndex <= caretIndex && part.endIndex >= caretIndex) {\n            maskIndex = index;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (maskIndex === undefined && valueParts.length < mask.length) {\n          maskIndex = valueParts.length; // first unused one\n        }\n\n        if (maskIndex && mask[maskIndex].fixed) {\n          maskIndex -= 1; // fixed mask parts are never \"active\"\n        }\n\n        if (maskIndex !== activeMaskIndex) {\n          setActiveMaskIndex(maskIndex);\n          setActiveOptionIndex(-1);\n          setShowDrop(maskIndex >= 0 && mask[maskIndex].options && true);\n        }\n      }, 10); // 10ms empirically chosen\n\n      return function () {\n        return clearTimeout(timer);\n      };\n    }\n\n    return undefined;\n  }, [activeMaskIndex, focus, mask, ref, valueParts]);\n  var setInputValue = useCallback(function (nextValue) {\n    // Calling set value function directly on input because React library\n    // overrides setter `event.target.value =` and loses original event\n    // target fidelity.\n    // https://stackoverflow.com/a/46012210 &&\n    // https://github.com/grommet/grommet/pull/3171#discussion_r296415239\n    var nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;\n    nativeInputValueSetter.call((ref || inputRef).current, nextValue);\n    var event = new Event('input', {\n      bubbles: true\n    });\n    (ref || inputRef).current.dispatchEvent(event);\n  }, [ref]); // This could be due to a paste or as the user is typing.\n\n  var onChangeInput = useCallback(function (event) {\n    // Align with the mask.\n    var nextValueParts = parseValue(mask, event.target.value);\n    var nextValue = nextValueParts.map(function (part) {\n      return part.part;\n    }).join('');\n\n    if (value !== nextValue) {\n      setInputValue(nextValue);\n      if (onChange) onChange(event);\n      setValue(nextValue);\n    }\n  }, [mask, onChange, setInputValue, setValue, value]);\n  var onOption = useCallback(function (option) {\n    return function () {\n      var nextValueParts = [].concat(valueParts);\n      nextValueParts[activeMaskIndex] = {\n        part: option\n      }; // add any fixed parts that follow\n\n      var index = activeMaskIndex + 1;\n\n      while (index < mask.length && !nextValueParts[index] && mask[index].fixed) {\n        nextValueParts[index] = {\n          part: mask[index].fixed\n        };\n        index += 1;\n      }\n\n      var nextValue = nextValueParts.map(function (part) {\n        return part.part;\n      }).join('');\n      setInputValue(nextValue); // restore focus to input\n\n      (ref || inputRef).current.focus();\n    };\n  }, [activeMaskIndex, mask, ref, setInputValue, valueParts]);\n  var onNextOption = useCallback(function (event) {\n    var item = mask[activeMaskIndex];\n\n    if (item && item.options) {\n      event.preventDefault();\n      var index = Math.min(activeOptionIndex + 1, item.options.length - 1);\n      setActiveOptionIndex(index);\n    }\n  }, [activeMaskIndex, activeOptionIndex, mask]);\n  var onPreviousOption = useCallback(function (event) {\n    if (activeMaskIndex >= 0 && mask[activeMaskIndex].options) {\n      event.preventDefault();\n      var index = Math.max(activeOptionIndex - 1, 0);\n      setActiveOptionIndex(index);\n    }\n  }, [activeMaskIndex, activeOptionIndex, mask]);\n  var onSelectOption = useCallback(function (event) {\n    if (activeMaskIndex >= 0 && activeOptionIndex >= 0) {\n      event.preventDefault();\n      var option = mask[activeMaskIndex].options[activeOptionIndex];\n      onOption(option)();\n    }\n  }, [activeMaskIndex, activeOptionIndex, mask, onOption]);\n  var onEsc = useCallback(function (event) {\n    if (showDrop) {\n      // we have to stop both synthetic events and native events\n      // drop and layer should not close by pressing esc on this input\n      event.stopPropagation();\n      event.nativeEvent.stopImmediatePropagation();\n      setShowDrop(false);\n    }\n  }, [showDrop]);\n\n  var renderPlaceholder = function renderPlaceholder() {\n    return mask.map(function (item) {\n      return item.placeholder || item.fixed;\n    }).join('');\n  };\n\n  return React.createElement(StyledMaskedInputContainer, {\n    plain: plain\n  }, icon && React.createElement(StyledIcon, {\n    reverse: reverse,\n    theme: theme\n  }, icon), React.createElement(Keyboard, {\n    onEsc: onEsc,\n    onTab: showDrop ? function () {\n      return setShowDrop(false);\n    } : undefined,\n    onLeft: undefined,\n    onRight: undefined,\n    onUp: onPreviousOption,\n    onDown: showDrop ? onNextOption : function () {\n      return setShowDrop(true);\n    },\n    onEnter: onSelectOption,\n    onKeyDown: onKeyDown\n  }, React.createElement(StyledMaskedInput, _extends({\n    ref: ref || inputRef,\n    id: id,\n    name: name,\n    autoComplete: \"off\",\n    plain: plain,\n    placeholder: placeholder || renderPlaceholder(),\n    icon: icon,\n    reverse: reverse,\n    focus: focus\n  }, rest, {\n    value: value || '',\n    theme: theme,\n    onFocus: function onFocus(event) {\n      setFocus(true);\n      setShowDrop(true);\n      if (_onFocus) _onFocus(event);\n    },\n    onBlur: function onBlur(event) {\n      setFocus(false); // This will be called when the user clicks on a suggestion,\n      // check for that and don't remove the drop in that case.\n      // Drop will already have removed itself if the user has focused\n      // outside of the Drop.\n\n      if (!dropRef.current) setShowDrop(false);\n      if (_onBlur) _onBlur(event);\n    },\n    onChange: onChangeInput\n  }))), showDrop && mask[activeMaskIndex] && mask[activeMaskIndex].options && React.createElement(Drop, {\n    id: id ? \"masked-input-drop__\" + id : undefined,\n    align: {\n      top: 'bottom',\n      left: 'left'\n    },\n    responsive: false,\n    target: (ref || inputRef).current,\n    onClickOutside: function onClickOutside() {\n      return setShowDrop(false);\n    },\n    onEsc: function onEsc() {\n      return setShowDrop(false);\n    }\n  }, React.createElement(Box, {\n    ref: dropRef\n  }, mask[activeMaskIndex].options.map(function (option, index) {\n    return React.createElement(Box, {\n      key: option,\n      flex: false\n    }, React.createElement(Button, {\n      tabIndex: \"-1\",\n      onClick: onOption(option),\n      onMouseOver: function onMouseOver() {\n        return setActiveOptionIndex(index);\n      },\n      onFocus: function onFocus() {},\n      active: index === activeOptionIndex,\n      hoverIndicator: \"background\"\n    }, React.createElement(Box, {\n      pad: {\n        horizontal: 'small',\n        vertical: 'xsmall'\n      }\n    }, option)));\n  }))));\n});\nMaskedInput.displayName = 'MaskedInput';\nvar MaskedInputDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  // eslint-disable-next-line global-require\n  MaskedInputDoc = require('./doc').doc(MaskedInput);\n}\n\nvar MaskedInputWrapper = MaskedInputDoc || MaskedInput;\nexport { MaskedInputWrapper as MaskedInput };","map":null,"metadata":{},"sourceType":"module"}