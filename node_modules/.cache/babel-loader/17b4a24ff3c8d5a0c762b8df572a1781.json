{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React, { useContext, useEffect, useRef, useState } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { normalizeColor, parseMetricToNum } from '../../utils';\nimport { StyledChart } from './StyledChart';\nimport { normalizeBounds, normalizeValues } from './utils';\nvar gradientMaskColor = '#ffffff'; // use constants so re-renders don't re-trigger effects\n\nvar defaultSize = {\n  height: 'small',\n  width: 'medium'\n};\nvar defaultValues = [];\nvar Chart = React.forwardRef(function (_ref, ref) {\n  var propsBounds = _ref.bounds,\n      color = _ref.color,\n      dash = _ref.dash,\n      gap = _ref.gap,\n      id = _ref.id,\n      onClick = _ref.onClick,\n      onHover = _ref.onHover,\n      _ref$overflow = _ref.overflow,\n      overflow = _ref$overflow === void 0 ? false : _ref$overflow,\n      round = _ref.round,\n      _ref$size = _ref.size,\n      propsSize = _ref$size === void 0 ? defaultSize : _ref$size,\n      _ref$thickness = _ref.thickness,\n      thickness = _ref$thickness === void 0 ? 'medium' : _ref$thickness,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? 'bar' : _ref$type,\n      _ref$values = _ref.values,\n      propsValues = _ref$values === void 0 ? defaultValues : _ref$values,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"bounds\", \"color\", \"dash\", \"gap\", \"id\", \"onClick\", \"onHover\", \"overflow\", \"round\", \"size\", \"thickness\", \"type\", \"values\"]);\n\n  var theme = useContext(ThemeContext);\n\n  var _useState = useState([]),\n      values = _useState[0],\n      setValues = _useState[1];\n\n  var _useState2 = useState([[0, 0], [0, 0]]),\n      bounds = _useState2[0],\n      setBounds = _useState2[1];\n\n  var _useState3 = useState([0, 0]),\n      containerSize = _useState3[0],\n      setContainerSize = _useState3[1];\n\n  var _useState4 = useState([0, 0]),\n      size = _useState4[0],\n      setSize = _useState4[1];\n\n  var _useState5 = useState([1, 1]),\n      scale = _useState5[0],\n      setScale = _useState5[1];\n\n  var _useState6 = useState(0),\n      strokeWidth = _useState6[0],\n      setStrokeWidth = _useState6[1];\n\n  var containerRef = ref || useRef(); // calculations\n\n  useEffect(function () {\n    var nextValues = normalizeValues(propsValues);\n    setValues(nextValues);\n    var nextBounds = normalizeBounds(propsBounds, nextValues);\n    setBounds(nextBounds);\n    var nextStrokeWidth = parseMetricToNum(theme.global.edgeSize[thickness] || thickness);\n    setStrokeWidth(nextStrokeWidth);\n    var gapWidth = gap ? parseMetricToNum(theme.global.edgeSize[gap] || gap) : nextStrokeWidth; // autoWidth is how wide we'd pefer\n\n    var autoWidth = nextStrokeWidth * nextValues.length + (nextValues.length - 1) * gapWidth;\n    var sizeWidth = typeof propsSize === 'string' ? propsSize : propsSize.width || defaultSize.width;\n    var width;\n\n    if (sizeWidth === 'full') {\n      width = containerSize[0];\n    } else if (sizeWidth === 'auto') {\n      width = autoWidth;\n    } else {\n      width = parseMetricToNum(theme.global.size[sizeWidth] || sizeWidth);\n    }\n\n    var sizeHeight = typeof propsSize === 'string' ? propsSize : propsSize.height || defaultSize.height;\n    var height;\n\n    if (sizeHeight === 'full') {\n      height = containerSize[1];\n    } else {\n      height = parseMetricToNum(theme.global.size[sizeHeight] || sizeHeight);\n    }\n\n    setSize([width, height]);\n    var nextScale = [(sizeWidth === 'auto' ? autoWidth : width) / (nextBounds[0][1] - nextBounds[0][0]), height / (nextBounds[1][1] - nextBounds[1][0])];\n    setScale(nextScale);\n  }, [containerSize, gap, propsBounds, propsSize, propsValues, theme.global.edgeSize, theme.global.size, thickness]); // set container size when we get ref or when size changes\n\n  if (containerRef.current && propsSize && (propsSize === 'full' || propsSize.height === 'full' || propsSize.width === 'full')) {\n    var containerNode = containerRef.current;\n\n    if (containerNode) {\n      var parentNode = containerNode.parentNode;\n\n      if (parentNode) {\n        var rect = parentNode.getBoundingClientRect();\n\n        if (rect.width !== containerSize[0] || rect.height !== containerSize[1]) {\n          setContainerSize([rect.width, rect.height]);\n        }\n      }\n    }\n  } // container size, if needed\n\n\n  useEffect(function () {\n    var onResize = function onResize() {\n      var parentNode = containerRef.current.parentNode;\n      var rect = parentNode.getBoundingClientRect();\n      setContainerSize([rect.width, rect.height]);\n    };\n\n    if (propsSize && (propsSize === 'full' || propsSize.width === 'full' || propsSize.height === 'full')) {\n      window.addEventListener('resize', onResize);\n      return function () {\n        return window.removeEventListener('resize', onResize);\n      };\n    }\n\n    return undefined;\n  }, [containerRef, propsSize]);\n  var useGradient = color && Array.isArray(color);\n  var strokeDasharray;\n\n  if (dash) {\n    if (round) {\n      strokeDasharray = strokeWidth + \" \" + strokeWidth * 1.5;\n    } else {\n      strokeDasharray = strokeWidth * 2 + \" \" + strokeWidth / 2;\n    }\n  }\n\n  var renderBars = function renderBars() {\n    return (values || []).map(function (valueArg, index) {\n      var label = valueArg.label,\n          valueOnHover = valueArg.onHover,\n          value = valueArg.value,\n          valueRest = _objectWithoutPropertiesLoose(valueArg, [\"label\", \"onHover\", \"value\"]);\n\n      var key = \"p-\" + index;\n      var bottom = value.length === 2 ? bounds[1][0] : value[1];\n      var top = value.length === 2 ? value[1] : value[2];\n\n      if (top !== 0) {\n        var d = \"M \" + (value[0] - bounds[0][0]) * scale[0] + \",\" + (\"\" + (size[1] - (bottom - bounds[1][0]) * scale[1])) + (\" L \" + (value[0] - bounds[0][0]) * scale[0] + \",\") + (\"\" + (size[1] - (top - bounds[1][0]) * scale[1]));\n        var hoverProps;\n\n        if (valueOnHover) {\n          hoverProps = {\n            onMouseOver: function onMouseOver() {\n              return valueOnHover(true);\n            },\n            onMouseLeave: function onMouseLeave() {\n              return valueOnHover(false);\n            }\n          };\n        }\n\n        var clickProps;\n\n        if (onClick) {\n          clickProps = {\n            onClick: onClick\n          };\n        }\n\n        return React.createElement(\"g\", {\n          key: key,\n          fill: \"none\"\n        }, React.createElement(\"title\", null, label), React.createElement(\"path\", _extends({\n          d: d\n        }, hoverProps, clickProps, valueRest, {\n          strokeDasharray: strokeDasharray\n        })));\n      }\n\n      return undefined;\n    });\n  };\n\n  var renderLine = function renderLine() {\n    var d = '';\n    (values || []).forEach(function (_ref2, index) {\n      var value = _ref2.value;\n      d += (index ? ' L' : 'M') + \" \" + (value[0] - bounds[0][0]) * scale[0] + \",\" + (\"\" + (size[1] - (value[1] - bounds[1][0]) * scale[1]));\n    });\n    var hoverProps;\n\n    if (onHover) {\n      hoverProps = {\n        onMouseOver: function onMouseOver() {\n          return onHover(true);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return onHover(false);\n        }\n      };\n    }\n\n    var clickProps;\n\n    if (onClick) {\n      clickProps = {\n        onClick: onClick\n      };\n    }\n\n    return React.createElement(\"g\", {\n      fill: \"none\"\n    }, React.createElement(\"path\", _extends({\n      d: d\n    }, hoverProps, clickProps, {\n      strokeDasharray: strokeDasharray\n    })));\n  };\n\n  var renderArea = function renderArea() {\n    var d = '';\n    (values || []).forEach(function (_ref3, index) {\n      var value = _ref3.value;\n      var top = value.length === 2 ? value[1] : value[2];\n      d += (!index ? 'M' : ' L') + \" \" + (value[0] - bounds[0][0]) * scale[0] + \",\" + (\"\" + (size[1] - (top - bounds[1][0]) * scale[1]));\n    });\n    (values || []).reverse().forEach(function (_ref4) {\n      var value = _ref4.value;\n      var bottom = value.length === 2 ? bounds[1][0] : value[1];\n      d += \" L \" + (value[0] - bounds[0][0]) * scale[0] + \",\" + (\"\" + (size[1] - (bottom - bounds[1][0]) * scale[1]));\n    });\n\n    if (d.length > 0) {\n      d += ' Z';\n    }\n\n    var hoverProps;\n\n    if (onHover) {\n      hoverProps = {\n        onMouseOver: function onMouseOver() {\n          return onHover(true);\n        },\n        onMouseLeave: function onMouseLeave() {\n          return onHover(false);\n        }\n      };\n    }\n\n    var clickProps;\n\n    if (onClick) {\n      clickProps = {\n        onClick: onClick\n      };\n    }\n\n    return React.createElement(\"g\", null, React.createElement(\"path\", _extends({\n      d: d\n    }, hoverProps, clickProps)));\n  };\n\n  var renderPoints = function renderPoints() {\n    return (values || []).map(function (valueArg, index) {\n      var label = valueArg.label,\n          valueOnHover = valueArg.onHover,\n          value = valueArg.value,\n          valueRest = _objectWithoutPropertiesLoose(valueArg, [\"label\", \"onHover\", \"value\"]);\n\n      var key = \"p-\" + index;\n      var hoverProps;\n\n      if (valueOnHover) {\n        hoverProps = {\n          onMouseOver: function onMouseOver() {\n            return valueOnHover(true);\n          },\n          onMouseLeave: function onMouseLeave() {\n            return valueOnHover(false);\n          }\n        };\n      }\n\n      var clickProps;\n\n      if (onClick) {\n        clickProps = {\n          onClick: onClick\n        };\n      }\n\n      var center = value.length === 2 ? value[1] : value[2];\n      var shape;\n\n      if (round) {\n        var cx = (value[0] - bounds[0][0]) * scale[0];\n        var cy = size[1] - (center - bounds[1][0]) * scale[1];\n        shape = React.createElement(\"circle\", _extends({\n          cx: cx,\n          cy: cy,\n          r: strokeWidth / 2\n        }, hoverProps, clickProps, valueRest));\n      } else {\n        var x = (value[0] - bounds[0][0]) * scale[0] - strokeWidth / 2;\n        var y = size[1] - (center - bounds[1][0]) * scale[1] - strokeWidth / 2;\n        shape = React.createElement(\"rect\", _extends({\n          x: x,\n          y: y,\n          width: strokeWidth,\n          height: strokeWidth\n        }, hoverProps, clickProps, valueRest));\n      }\n\n      return React.createElement(\"g\", {\n        key: key,\n        stroke: \"none\"\n      }, React.createElement(\"title\", null, label), shape);\n    });\n  };\n\n  var contents;\n\n  if (type === 'bar') {\n    contents = renderBars();\n  } else if (type === 'line') {\n    contents = renderLine();\n  } else if (type === 'area') {\n    contents = renderArea();\n  } else if (type === 'point') {\n    contents = renderPoints();\n  }\n\n  var viewBounds = overflow ? [0, 0, size[0], size[1]] : [-(strokeWidth / 2), -(strokeWidth / 2), size[0] + strokeWidth, size[1] + strokeWidth];\n  var viewBox = viewBounds.join(' ');\n  var colorName;\n\n  if (!useGradient) {\n    if (color && color.color) colorName = color.color;else if (color) colorName = color;else if (theme.chart && theme.chart.color) colorName = theme.chart.color;\n  }\n\n  var opacity = color && color.opacity ? theme.global.opacity[color.opacity] : undefined;\n  var stroke;\n\n  if (type !== 'point') {\n    if (useGradient) stroke = gradientMaskColor;else stroke = normalizeColor(colorName, theme);\n  } else stroke = 'none';\n\n  var fill;\n\n  if (type === 'point' || type === 'area') {\n    if (useGradient) fill = gradientMaskColor;else fill = normalizeColor(colorName, theme);\n  } else fill = 'none';\n\n  var drawing = React.createElement(\"g\", {\n    stroke: stroke,\n    strokeWidth: type !== 'point' ? strokeWidth : undefined,\n    fill: fill,\n    strokeLinecap: round ? 'round' : 'butt',\n    strokeLinejoin: round ? 'round' : 'miter',\n    opacity: opacity\n  }, contents);\n  var defs;\n  var gradientRect;\n\n  if (useGradient && size[1]) {\n    var gradientId = id + \"-gradient\";\n    var maskId = id + \"-mask\";\n    defs = React.createElement(\"defs\", null, React.createElement(\"linearGradient\", {\n      id: gradientId,\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 1\n    }, color.sort(function (c1, c2) {\n      return c2.value - c1.value;\n    }).map(function (_ref5) {\n      var value = _ref5.value,\n          gradientColor = _ref5.color;\n      return React.createElement(\"stop\", {\n        key: value,\n        offset: (size[1] - (value - bounds[1][0]) * scale[1]) / size[1],\n        stopColor: normalizeColor(gradientColor, theme)\n      });\n    })), React.createElement(\"mask\", {\n      id: maskId\n    }, drawing));\n    gradientRect = React.createElement(\"rect\", {\n      x: viewBounds[0],\n      y: viewBounds[1],\n      width: viewBounds[2],\n      height: viewBounds[3],\n      fill: \"url(#\" + gradientId + \")\",\n      mask: \"url(#\" + maskId + \")\"\n    });\n  }\n\n  return React.createElement(StyledChart, _extends({\n    ref: containerRef,\n    id: id,\n    viewBox: viewBox,\n    preserveAspectRatio: \"none\",\n    width: size === 'full' ? '100%' : size[0],\n    height: size === 'full' ? '100%' : size[1]\n  }, rest), defs, useGradient ? gradientRect : drawing);\n});\nChart.displayName = 'Chart';\nvar ChartDoc;\n\nif (process.env.NODE_ENV !== 'production') {\n  ChartDoc = require('./doc').doc(Chart); // eslint-disable-line global-require\n}\n\nvar ChartWrapper = ChartDoc || Chart;\nexport { ChartWrapper as Chart };","map":null,"metadata":{},"sourceType":"module"}